# pinball2elf 
*pinball2elf* is a tool to create stand-alone Linux binaries from checkpoints for arbitrary portions of execution of other Linux programs . The checkpoints it converts are called ‘pinballs’ and they are generated by “Program Record Replay Toolkit” (aka PinPlay kit) that is available at [Intel PinPlay](http://www.pinplay.org). *pinball2elf* was developed by Alexander Isaev between 2015-2017 while he was at Intel. Some enhancements and use-case development was done by Harish Patil (Intel) with input from Trevor Carlson(NUS), Karthik Sankaranarayanan(Intel), and Wim Heirman(Intel).

## Quick Start Example
1. Build pinball2elf

    `cd src`
    
    `make all`

    `cd ..`


2. Test with a single-threaded pinball

    `cd examples/ST`

    `./testST.sh`

This shows:
### Creation and running of *basic* elfie
------------------------------------------

```
  Running ../../scripts/pinball2elf.basic.sh pinball.st/log_0
  Running ./pinball.st/log_0.elfie
ELFIE_COREBASE=0
core_base: 0
 pid: 4203
process_callback() [ inside ELFie] called. Num_threads: 1
 tid: 4203
thread_callback() [ inside ELFie] called for thread 0
Hello world 1
---------------------
```
### Creation and running of *perf* elfie
-----------------------------------------
```
  Running ../../scripts/pinball2elf.perf.sh pinball.st/log_0
  export ELFIE_PERFLIST=0:0,0:1,1:1
   [ based on /usr/include/linux/perf_event.h
     Comma separeted pairs 'perftype:counter'
     perftype: 0 --> HW 1 --> SW
     HW counter: 0 --> PERF_COUNT_HW_CPU_CYCLES
     HW counter: 1 --> PERF_COUNT_HW_CPU_INSTRUCTIONS
     SW counter: 0 --> PERF_COUNT_SW_CPU_CLOCK
      ... <see perf_event.h:'enum perf_hw_ids' and 'enum perf_sw_ids']
  Running ./pinball.st/log_0.perf.elfie
ELFIE_COREBASE=0
ELFIE_PERFLIST=0:0,0:1,1:1
Will set affinity using core_base: 0
  elfie tid: 0  core id: 0
------------------------------------------------
------------------------------------------------
Hello world 1
    graceful exit SUCCESS
```
### Show performance counters reported in *st.0.perf.txt*
----------------------------------------------------------
```
  Performance counters reported in st.0.perf.txt
ROI start: TSC 74744470196596112
Thread start: TSC 74744470231500862
------------------------------------------------
Simulation end: TSC 74744470232488632
        Sim-end-icount 3922
hw_cpu_cycles:45584 hw_instructions:3964 sw_task_clock:134934 
------------------------------------------------
Thread end: TSC 74744470232782076
ROI end: TSC 74744470232944672
hw_cpu_cycles:49566 hw_instructions:4647 sw_task_clock:184142 
```
--------------------------------------------------------
## ELFie creation basics
The tool *pinball2elf*, supports three types of callbacks:
```
  -p FUNC, --process-cbk FUNC      name of process start callback
  -e FUNC, --process-exit-cbk FUNC name of process exit callback
  -t FUNC, --thread-cbk FUNC       name of thread start callback
```
### Scripts provided
```
scripts/
├── pinball2elf.basic.sh
├── pinball2elf.perf.sh
└── pinball2elf.sim.sh
```
### Instrumentation code
```
instrumentation/
├── basic_callbacks.c
├── environ.c
├── perf_callbacks.c
├── set_heap.c
└── sim_callbacks.c

environ.c : supports the processing of ELFIE_* environment variables.
set_heap.c : supports the handling of brk() system call behavior based on SYSSTATE
```
### ELFie types supported
1. **basic ELFie**
```
script: pinball2elf.basic.sh
  Usage: scripts/pinball2elf.basic.sh pinball
instrumentation: basic_callbacks.c
callbacks used:
-p elfie_on_start: outputs informational messages; processes SYSSTATE
-t elfie_on_thread_start: outputs informational messages
Graceful exit : NO
```
2. **Simulator(sim) ELFie**
```
script: pinball2elf.sim.sh
  Usage: scripts/pinball2elf.sim.sh pinball <message>
instrumentation: sim_callbacks.c
callbacks used:
-p elfie_on_start: processes SYSSTATE; checks if ELFIE_COREBASE is a positive number
-t elfie_on_thread_start:  sets affinity for theread etid to 'COREBASE+apptid'
Graceful exit : NO ( the simulator is supposed to end ELFie execution)
```
3. **Performance monitoring(perf) ELFie**
```
script: pinball2elf.perf.sh
  Usage :  scripts/pinball2elf.perf.sh  pinball filename-prefix <use_warmup>
instrumentation: perf_callbacks.c
callbacks used:
-p elfie_on_start: processes SYSSTATE; checks if ELFIE_COREBASE is a positive number
                     Opens per-thread perf stats files
-t elfie_on_thread_start:  sets affinity for theread etid to 'COREBASE+apptid'
                 * sets up warmup/simulation end handlers
                 * Uses "ELFIE_WARMUP" to decide whether to use warmup.
                 * Uses "ELFIE_PCCONT" to decide how to end warmup/simulation regions
                 * sets up performance counters to end warmup/simulation regions
                      either using instruction counts or PC + count
                 * Based on ELFIE_PERFLIST, enables performance counting
                   (  based on /usr/include/linux/perf_event.h
                      perftype: 0 --> HW 1 --> SW
                      HW counter: 0 --> PERF_COUNT_HW_CPU_CYCLES
                      HW counter: 1 --> PERF_COUNT_HW_CPU_INSTRUCTIONS
                      SW counter: 0 --> PERF_COUNT_SW_CPU_CLOCK
                       ... <see perf_event.h:'enum perf_hw_ids' and 'enum perf_sw_ids')          
-e elfie_on_exit: runs in the watch thread, outputs final performance counter 
                  values for each application thread. 

A watch thread is first created, it creates the main application thread and waits
 for it to exit. The main application thread creates other application threads if
  needed

Graceful exit : YES: either icount of pc+count used for exiting each thread.
```
--------------------------------------------------------
## Input to *pinball2elf*

User-level checkpoints known as *pinballs* are input to the *pinbll2elf* tool. These are created using the [PinPlay](http://wwww.pinplay.org) tool kit. A *pinball* is a collection of files capturing the execution state of a "Region of Interest" (ROI) from an application execution. A typical sequence of commands to generate and test a *pinball* suitable for *pinball2elf* is shown below:
### Creating a *fat* pinball
 (Assuming 'bash' shell)
```
  export PIN_ROOT=<absolute path to the PinPlay kit>

  export LD_BIND_NOW=1 #to load any application dynamic libraries early

  $PIN_ROOT/pin -t $PIN_ROOT/extras/pinplay/bin/intel64/pinplay-driver.so -log -log:fat -log:mt -log:compressed bzip2 -log:basename pinball/foo <ROI specification> -- <application arguments>
```
### Test the *fat* pinball with *injection-less replay*
This step makes sure the pinball can be replayed *without injections* of any  system call side-effects.

```
$PIN_ROOT/pin -t $PIN_ROOT/extras/pinplay/bin/intel64/pinplay-driver.so -replay -replay:addr_trans -replay:inection 0  -replay:basename pinball/foo -- $PIN_ROOT/extras/pinplay/bin/intel64/nullapp
```
If the ROI does any file inpout, this replay step may fail. You will need to extract from the pinball the necessary OS state that the ROI uses.

### (Optionl) Create SYSSTATE directory for the pinball
* Build the pintool pinball-sysstate.so
```
    cd *pinball2elf-directory*

    cd pintool/SYSSTATE

    make
```

 This will create *$PIN_ROOT/extras/pinplay/bin/intel64/pinball-sysstate.so*.

#### Create SYSSTATE for the pinball
```
 $PIN_ROOT/pin -t $PIN_ROOT/extras/pinplay/bin/intel64/pinball-sysstate.so -replay -replay:addr_trans -replay:basename pinball.st/log_0 -sysstate:out pinball.st/log_0 -- $PIN_ROOT/extras/pinplay/bin/intel64/nullapp 
Will produce sysstate in pinball.st/log_0.sysstate
Producer pinball.st/log_0
Hello world 1
 ROI used pre-existing FD : 1
Creates:

pinball.st/log_0.sysstate/
└── workdir
    └── FD_1
```
### (Optional) warmup specification: Create  *event_icount.tid.txt* files for pinball
* Build the pintool pinball-sysstate.so
```
    cd *pinball2elf-directory*

    cd pintool/EventCounter

    make
```

 This will create *$PIN_ROOT/extras/pinplay/bin/intel64/event_counter.so*.
#### Create warmup/simulation specification for the pinball
* warmup ends/simulation starts at icount 3000 : -pinplay:control start:icount:3000:global
* simulation ends at icount 3500 : -pinplay:control stop:icount:3500:global
```
$PIN_ROOT/pin -t $PIN_ROOT/extras/pinplay/bin/intel64/event_counter.so -thread_count 1 -prefix pinball.st/log_0 -pinplay:control start:icount:3000:global -pinplay:control stop:icount:3500:global -replay -replay:addr_trans -replay:basename pinball.st/log_0 -- $PIN_ROOT/extras/pinplay/bin/intel64/nullapp
Hello world 1
 global icount 2998 Sim-Start
 global icount 3496 Sim-End
```
**Creates event_icount file**
```
 cat pinball.st/log_0.event_icount.0.txt 
Sim-Start global_icount: 2998
Sim-Start tid: 0 icount 2998
Sim-End global_icount: 3496
Sim-End tid: 0 icount 3496
Fini  global_icount: 3922
Fini  tid: 0 icount 3922
```
#### Example of PC+count in warmup/simulation specification
* Specify warmup/simulation end using PC+count

 -pinplay:control start:address:0x000814187:count84738:global -pinplay:control stop:address:0x0009decb1:count34069:global

* Also monitor warmup-end and simulation-end PCs

-watch\_addr 0x000814187 -watch\_addr 0x0009decb1

```
RPB=<an 8-threaded pinball with known warmup-end/simulation end PC+count values>
$PIN_ROOT/pin -t $PIN_ROOT/extras/dcfg/bin/intel64/global_event_icounter.so -thread_count 8  -prefix $RPB  -watch_addr 0x000814187 -watch_addr 0x0009decb1  -pinplay:control start:address:0x000814187:count84738:global -pinplay:control stop:address:0x0009decb1:count34069:global -replay -replay:addr_trans -replay:basename $RPB -- $PIN_ROOT/extras/pinplay/bin/intel64/nullapp

Creates 8 $RPB.event_icount.tid.txt files: one for each thread
Example event_icount file:

cat $RPB.event_icount.3.txt 
Sim-Start global_icount: 1597134619
Sim-Start tid: 3 icount 217651514
        Marker  814187  global_addrcount: 84737
        Marker  814187 tid: 3 addrcount 12816
        Marker  9decb1  global_addrcount: 0
        Marker  9decb1 tid: 3 addrcount 0
Sim-End global_icount: 2400630567
Sim-End tid: 3 icount 278389598
        Marker  814187  global_addrcount: 116928
        Marker  814187 tid: 3 addrcount 12960
        Marker  9decb1  global_addrcount: 34067
        Marker  9decb1 tid: 3 addrcount 4368
Fini  global_icount: 2400722002
Fini  tid: 3 icount 278420906
Addr  814187  global_addrcount: 116928
Addr  814187 tid: 3 addrcount 12960
Addr  9decb1  global_addrcount: 34070
Addr  9decb1 tid: 3 addrcount 4368

```
